

/*

Нойзовый генеративный синтезатор на 
осцилляторах типа saw (пилообразная 
волна).

Идея такова: есть несколько 
дорожек-семплов, на которых генерируются 
последовательности изменений частоты 
(freq), громкости (amp) и панорамы (pan) 
каждого из семплов. Семплы 
воспроизводятся в цикле, нажатием на 
экран можно случайным образом 
регенерировать семпл на той или иной 
дорожке, высотой нажатия определяя 
скорость воспроизведения семпла 
(чем выше тем быстрее). Можно отключать 
семплы нажатием в нижней части экрана. 
Каждый семпл отображается на экране в 
виде следа движущегося квадрата, высота 
квадрата определяется частотой звука, 
размер - амплитудой (панорама не 
визуализируется). 

Технически, каждая дорожка-семпл 
находится в объекте типа Root. По 
необходимости, объект инициализирует 
дорожку, формируя последовательности 
псевдослучайных чисел на основе шума 
Перлина, после чего пересчитывает 
последовательности частот, амплитуд и 
панорам, а также соответствующие 
координаты квадрата для его отрисовки.

Особенности генерации: 
Кроме пилообразного осциллятора, на к
аждой дорожке сидит ещё синусоидальный 
осциллятор, октавой ниже.
Длительности семплов приводятся 
(округляются) к ста миллисекундам, для 
согласования ритмического рисунка.

Особенности кода:
Все параметры, которые имеет смысл 
варьировать, отмечены комментариями, 
в т.ч. пустыми //
Имеет смысл варьировать: число дорожек, 
максимальную длительность семпла, число 
октав шума перлина (определяет 
разнообразие семпла), диапазон частот. 
В части отрисовки можно крутить всё 
что угодно.

*/


String version = "16"; // номер версии, 
//печатается в названии слева сверху
int nRoots = 6; // число дорожек-семплов
float mutezone = 0.94; // относительный 
//размер зоны выключения дорожки на экране


ArrayList<Root> rs = new ArrayList<Root>();

float basemin; // больший базовый размер, 
//удобно для экранов мобильных устройств
float basemax; // меньший базовый размер


void setup() {

  // size(400, 600, P3D);
  fullScreen(P3D);

  basemin = min(width, height);
  basemax = max(width, height);

  // первичное создание объектов
  for (int i=0; i < nRoots; i++) {
    Root r = new Root();
    r.init(nRoots);
    r.saw = new SawOsc(this);
    r.saw.play();
    r.sino = new SinOsc(this);
    r.sino.play();
    rs.add(r);
  }

  // fillMidiFreqs(); //// включить если 
  //нужно будет округлять частоты к midi

  strokeCap(PROJECT);
}


void draw() {

  // заливка фона с прозрачностью
  fill(0, 10);
  noStroke();
  rect(0, 0, width, height);

  // название и номер версии
  fill(255);
  textSize(basemax*0.01);
  text("noise gen saw " + version, 12, 20);

  // отрисовка линии отключения дорожек
  stroke(155, 13);
  strokeWeight(1);
  line(0, mutezone*height, width, mutezone*height);

  translate(0, height*.5);

  int n = rs.size();
  // координаты для отслеживания - на 
  //какую дорожку произошло нажатие
  float apxs[] = new float[n];
  float apys[] = new float[n];

  for (int i=0; i < n; i++) {
    pushMatrix();
    float xsh = i * width/n + width/n/2;
    translate(xsh, 0);
    Root r = rs.get(i);
    r.display();

    apxs[i] = xsh;
    apys[i] = r.coords.get(r.it).y;

    popMatrix();
  }


  noFill();
  stroke(255, 100);
  strokeWeight(2);

  // реинициализация дорожки при нажалии на неё
  if (mousePressed) {
    // отрисовка нажатия
    strokeWeight(basemin*.044);
    stroke(255, 0, 0);
    translate(0, -height*.5);
    point(mouseX, mouseY);

    // определение номера дорожки, 
    // на которую произведено нажатие
    int nScreen = mouseX/(width/nRoots); // здесь, о чудо, целочисленное деление нам помогает

    // остановка осцилляторов
    rs.get(nScreen).saw.stop();
    rs.get(nScreen).sino.stop();

    // инициализация объекта, запуск 
    //осцилляторов
    Root r = new Root();
    r.duration = map(mouseY, 0, width, 100, 4000); //
    r.duration = round(r.duration*.01)*100; // округляем до 100 ms

    r.init(nRoots);
    r.saw = new SawOsc(this);
    r.saw.play();
    r.saw.amp(0.01); // антиклипинг (до 
    //пересчёта громкости в следующем 
    //цикле draw она устанавливается 
    //примерно на ноль)
    r.sino = new SinOsc(this);
    r.sino.play();
    r.sino.amp(0.01); // антиклипинг

    // остановка осциллятора в случае 
    //нажатия в области выключения дорожек
    if (mouseY > height*mutezone) {
      r.saw.stop();
      r.sino.stop();
    }

    // замена старой дорожки (на только 
    //что созданную созданную) в списке объектов
    rs.remove(nScreen);
    rs.add(nScreen, r);
  }
}
